#pragma once

//! Helper functions for intialising GridTrack's from styles
//! This mainly consists of evaluating GridAutoTracks

#include <taffy/compute/grid/types/grid_track/GridTrack.hpp>
#include <taffy/compute/grid/types/grid_track_counts/TrackCounts.hpp>

#include <taffy/geometry/AbsoluteAxis.hpp>

#include <taffy/style/grid/GridTrackRepetition.hpp>
#include <taffy/style/dimensions/LengthPercentage.hpp>
#include <taffy/style/grid/NonRepeatedTrackSizingFunction.hpp>
#include <taffy/style/mod/Style.hpp>
#include <taffy/style/grid/TrackSizingFunction.hpp>

#include <taffy/util/sys/GridTrackVec.hpp>
#include <taffy/util/sys/Vec.hpp>
#include <taffy/util/math/MaybeMath.hpp>
#include <taffy/util/resolve/ResolveOrZero.hpp>

#include <taffy/support/rust_utils/saturating_sub.hpp>
#include <taffy/support/rust_utils/floor.hpp>
#include <taffy/support/rust_utils/ceil.hpp>

#include <taffy/support/rust_utils/Slice.hpp>

#include <taffy/support/rust_utils/iter_utils/all.hpp>
#include <taffy/support/rust_utils/iter_utils/any.hpp>
#include <taffy/support/rust_utils/iter_utils/filter_and_count.hpp>
#include <taffy/support/rust_utils/iter_utils/map_and_sum.hpp>

namespace taffy {

// -----------------------------------------------------------------------------

void create_implicit_tracks__repeat(
    Vec<GridTrack>& tracks,
    uint16_t count,

    const NonRepeatedTrackSizingFunction& repeated,
    
    const LengthPercentage& gap
);
void create_implicit_tracks__cycle(
    Vec<GridTrack>& tracks,
    uint16_t count,
    
    Slice<NonRepeatedTrackSizingFunction const> cycled,
    size_t skip_offset,

    LengthPercentage gap
);

// -----------------------------------------------------------------------------

namespace impl {

    /* 
        # Example of usage

        @code{.cpp}
        const std::vector<int> v = {1, 2, 3, 4, 5};

        auto iter = cycle(v, 3);
        for(std::size_t i = 0; i < 12; ++i)
        {
            printf("%i, ", *iter.next());
        }

        // Ouput: 3, 4, 5, 1, 2, 3, 4, 5, 1, 2, 3, 4,
        @endcode
    */

    template <typename Iter>
    class CycleIterator
    {
        Iter _begin;
        Iter _end;
        Iter _it;

    public:

        CycleIterator(Iter begin, Iter end, size_t size, size_t skip_offset = 0)
            : _begin(begin)
            , _end(end)
            , _it(
                (size == 0) ? // Check to prevent from division-by-zero
                    begin
                : // (size != 0)
                    begin + (skip_offset % size)
            )
        {}

        Iter next()
        {
            Iter ret = _it;

            _it++;
            if( _it == _end ) {
                _it = _begin;
            }

            return ret;
        }
    };

    // Shortcut functions with iterator-type deduction :)
    template <typename Container, typename Iter = typename Container::const_iterator>
    inline CycleIterator<Iter> cycle(const Container& container, size_t skip_offset = 0)
    {
        return CycleIterator<Iter>(container.begin(), container.end(), container.size(), skip_offset);
    }
    template <typename Container, typename Iter = typename Container::iterator>
    inline CycleIterator<Iter> cycle_mut(const Container& container, size_t skip_offset = 0)
    {
        return CycleIterator<Iter>(container.begin(), container.end(), container.size(), skip_offset);
    }

} // namespace impl

// -----------------------------------------------------------------------------

/// Compute the number of rows and columns in the explicit grid
/* RUST
    pub(crate) fn compute_explicit_grid_size_in_axis(style: &Style, axis: AbsoluteAxis) -> u16
*/
inline uint16_t compute_explicit_grid_size_in_axis(
    const Style& style,
    AbsoluteAxis axis
)
{
    // Load the grid-template-rows or grid-template-columns definition (depending on the axis)
    const auto Template = style.grid_template_tracks(axis);

    // If template contains no tracks, then there are trivially zero explcit tracks
    if( Template.empty() ) {
        return 0;
    }

    // If there are any repetitions that contains no tracks, then the whole definition should be considered invalid
    // and we default to no explicit tracks
    const auto template_has_repetitions_with_zero_tracks =
        any(Template, [](const TrackSizingFunction& track_def) {
            return
                (track_def.type() == TrackSizingFunction::Type::Single) ?
                    false
                : // TrackSizingFunction::Type::Repeat
                    track_def.repeat_funcs().empty();
        });
    if( template_has_repetitions_with_zero_tracks ) {
        return 0;
    }

    // Compute that number of track generated by single track definition and repetitions with a fixed repetition count
    const auto non_auto_repeating_track_count =
        map_and_sum<uint16_t>(Template, [](const TrackSizingFunction& track_def)
        {
            return
                (track_def.type() == TrackSizingFunction::Type::Single) ?
                    1
                : // TrackSizingFunction::Type::Repeat
                    (track_def.repeat_repetition().type() == GridTrackRepetition::Type::Count) ?
                        track_def.repeat_repetition().value() * static_cast<uint16_t>(track_def.repeat_funcs().size())
                    : // track_def.repeat_repetition().type() == AutoFit || AutoFill
                        0;
        });

    const auto auto_repetition_count =
        static_cast<uint16_t>(
            filter_and_count(Template, [](const TrackSizingFunction& track_def) { return track_def.is_auto_repetition(); })
        );
    const auto all_track_defs_have_fixed_component =
        all(Template, [](const TrackSizingFunction& track_def) {
            return
                (track_def.type() == TrackSizingFunction::Type::Single) ?
                    track_def.single_func().has_fixed_component()
                : // TrackSizingFunction::Type::Repeat
                    all(track_def.repeat_funcs(), [](const NonRepeatedTrackSizingFunction& sizing_function) { return sizing_function.has_fixed_component(); });
        });

    const auto template_is_valid =
        auto_repetition_count == 0 || (auto_repetition_count == 1 && all_track_defs_have_fixed_component);

    // If the template is invalid because it contains multiple auto-repetition definitions or it combines an auto-repetition
    // definition with non-fixed-size track sizing functions, then disregard it entirely and default to zero explicit tracks
    if( !template_is_valid ) {
        return 0;
    }

    // If there are no repetitions, then the number of explicit tracks is simply equal to the lengths of the track definition
    // vector (as each item in the Vec represents one track).
    if( auto_repetition_count == 0 ) {
        return non_auto_repeating_track_count;
    }

    const auto repetition_definition = [&]() -> Option<GridTrackVec<NonRepeatedTrackSizingFunction>>
    {
        for(const auto& def : Template)
        {
            const auto comparation_result = [&]() -> Option<GridTrackVec<NonRepeatedTrackSizingFunction>>
            {
                return
                    (def.type() == TrackSizingFunction::Type::Single) ?
                        None
                    : // TrackSizingFunction::Type::Repeat
                        (def.repeat_repetition().type() == GridTrackRepetition::Type::Count) ?
                            None
                        : // def.repeat_repetition().type() == GridTrackRepetitio::AutoFit || AutoFill
                            Some(def.repeat_funcs());
            }();

            if(comparation_result.is_some())
                return comparation_result;
        }

        return None;
    }().unwrap();
    const auto repetition_track_count = static_cast<uint16_t>(repetition_definition.size());

    // Otherwise, run logic to resolve the auto-repeated track count:
    //
    // If the grid container has a definite size or max size in the relevant axis:
    //   - then the number of repetitions is the largest possible positive integer that does not cause the grid to overflow the content
    //     box of its grid container.
    // Otherwise, if the grid container has a definite min size in the relevant axis:
    //   - then the number of repetitions is the smallest possible positive integer that fulfills that minimum requirement
    // Otherwise, the specified track list repeats only once.
    const auto style_size = style.size.get_abs(axis).into_option();
    const auto style_min_size = style.min_size.get_abs(axis).into_option();
    const auto style_max_size = style.max_size.get_abs(axis).into_option();

    const auto outer_container_size = MaybeMath(style_size).maybe_min(style_max_size).Or(style_max_size).Or(style_min_size);
    const auto inner_container_size = outer_container_size.map<float>([&](float size) {
        const auto padding_sum = ResolveOrZero(style.padding).resolve_or_zero(outer_container_size).grid_axis_sum(axis);
        const auto border_sum = ResolveOrZero(style.border).resolve_or_zero(outer_container_size).grid_axis_sum(axis);
        return size - padding_sum - border_sum;
    });
    const auto size_is_maximum = style_size.is_some() || style_max_size.is_some();

    // Determine the number of repetitions
    const uint16_t num_repetitions = 
        inner_container_size.is_none() ?
            1
        : // Some
            [&]() -> uint16_t
            {
                const auto parent_size = Some(inner_container_size.value());

                /// ...treating each track as its max track sizing function if that is definite or as its minimum track sizing function
                /// otherwise, flooring the max track sizing function by the min track sizing function if both are definite
                static const auto track_definite_value = [](const NonRepeatedTrackSizingFunction& sizing_function, const Option<float>& parent_size) -> float {
                    const auto max_size = sizing_function.max.definite_value(parent_size);
                    const auto min_size = sizing_function.max.definite_value(parent_size);
                    return max_size.map<float>([&](float max) { return MaybeMath(max).maybe_min(min_size); }).Or(min_size).unwrap();
                };

                const float non_repeating_track_used_space =
                    map_and_sum<float>(Template, [&](const TrackSizingFunction& track_def)
                    {
                        return
                            (track_def.type() == TrackSizingFunction::Type::Single) ?
                                track_definite_value(track_def.single_func(), parent_size)
                            : // TrackSizingFunction::Type::Repeat
                                (track_def.repeat_repetition().type() == GridTrackRepetition::Type::Count) ?
                                    [&] {
                                        const auto sum = map_and_sum<float>(track_def.repeat_funcs(), [&](const NonRepeatedTrackSizingFunction& sizing_function) {
                                            return track_definite_value(sizing_function, parent_size);
                                        });
                                        return sum * static_cast<float>(track_def.repeat_repetition().value());
                                    }()
                                : // TrackSizingFunction::Type::AutoFit || AutoFill
                                    0.0f;
                    });
                const auto gap_size = ResolveOrZero(style.gap.get_abs(axis)).resolve_or_zero(Option<float>{inner_container_size});

                // Compute the amount of space that a single repetition of the repeated track list takes
                const float per_repetition_track_used_space =
                    map_and_sum<float>(repetition_definition, [&](const NonRepeatedTrackSizingFunction& sizing_function) {
                        return track_definite_value(sizing_function, parent_size);
                    });

                // We special case the first repetition here because the number of gaps in the first repetition
                // depends on the number of non-repeating tracks in the template
                const auto first_repetition_and_non_repeating_tracks_used_space = non_repeating_track_used_space
                    + per_repetition_track_used_space
                    + (static_cast<float>(saturating_sub<uint16_t>(non_auto_repeating_track_count + repetition_track_count, 1)) * gap_size); // TODO: is here saturating_sub<uint16_t> ok (without type it deduced as saturating_sub(int, int) ? or maybe it must be uint32_t ?

                // If a single repetition already overflows the container then we return 1 as the repetition count
                // (the number of repetitions is floored at 1)
                if( first_repetition_and_non_repeating_tracks_used_space > inner_container_size ) {
                    return uint16_t{1};
                } else {
                    const auto per_repetition_gap_used_space = static_cast<float>(repetition_definition.size()) * gap_size;
                    const auto per_repetition_used_space = per_repetition_track_used_space + per_repetition_gap_used_space;
                    const auto num_repetition_that_fit = (inner_container_size.value()
                        - first_repetition_and_non_repeating_tracks_used_space)
                        / per_repetition_used_space;

                    // If the container size is a preferred or maximum size:
                    //   Then we return the maximum number of repetitions that fit into the container without overflowing.
                    // If the container size is a minimum size:
                    //   - Then we return the minimum number of repititions required to overflow the size.
                    //
                    // In all cases we add the additional repetition that was already accounted for in the special-case computation above
                    if( size_is_maximum ) {
                        return static_cast<uint16_t>(floor(num_repetition_that_fit)) + 1;
                    } else {
                        return static_cast<uint16_t>(ceil(num_repetition_that_fit)) + 1;
                    }
                }
            }();

    return non_auto_repeating_track_count + (repetition_track_count * num_repetitions);
}

/// Resolve the track sizing functions of explicit tracks, automatically created tracks, and gutters
/// given a set of track counts and all of the relevant styles
/* RUST
    pub(super) fn initialize_grid_tracks(
        tracks: &mut Vec<GridTrack>,
        counts: TrackCounts,
        track_template: &GridTrackVec<TrackSizingFunction>,
        auto_tracks: &Vec<NonRepeatedTrackSizingFunction>,
        gap: LengthPercentage,
        track_has_items: impl Fn(usize) -> bool,
    )
*/
inline void initialize_grid_tracks(
    Vec<GridTrack>& tracks,
    const TrackCounts& counts,
    const GridTrackVec<TrackSizingFunction>& track_template,
    const Vec<NonRepeatedTrackSizingFunction>& auto_tracks,
    const LengthPercentage& gap,
    const std::function< bool (size_t) >& track_has_items
)
{
    // Clear vector (in case this is a re-layout), reserve space for all tracks ahead of time to reduce allocations,
    // and push the initial gutter
    tracks.clear();
    tracks.reserve((counts.len() * 2) + 1);
    tracks.push_back(GridTrack::gutter(gap));

    // Create negative implicit tracks
    if( counts.negative_implicit > 0 ) {
        if( auto_tracks.empty() ) {
            // let iter = core::iter::repeat(NonRepeatedTrackSizingFunction::AUTO);
            // create_implicit_tracks(tracks, counts.negative_implicit, iter, gap)
            create_implicit_tracks__repeat(tracks, counts.negative_implicit, NonRepeatedTrackSizingFunction::AUTO(), gap);
        } else {
            const auto offset = auto_tracks.size() - (static_cast<size_t>(counts.negative_implicit) % auto_tracks.size());

            // let iter = auto_tracks.iter().copied().cycle().skip(offset);
            // create_implicit_tracks(tracks, counts.negative_implicit, iter, gap)
            create_implicit_tracks__cycle(tracks, counts.negative_implicit, auto_tracks, offset, gap);
        }
    }

    auto current_track_index = static_cast<size_t>(counts.negative_implicit);

    // Create explicit tracks
    // An explicit check against the count (rather than just relying on track_template being empty) is required here
    // because a count of zero can result from the track_template being invalid, in which case it should be ignored.
    if( counts.Explicit > 0 ) {
        for(const auto& track_sizing_function : track_template)
        {
            if(track_sizing_function.type() == TrackSizingFunction::Type::Single) {
                tracks.push_back(GridTrack::New(
                    track_sizing_function.single_func().min_sizing_function(),
                    track_sizing_function.single_func().max_sizing_function()
                ));
                tracks.push_back(GridTrack::gutter(gap));
                current_track_index += 1;
            }
            else if(
                track_sizing_function.type() == TrackSizingFunction::Type::Repeat &&
                track_sizing_function.repeat_repetition().type() == GridTrackRepetition::Type::Count
            )
            {
                const auto count = track_sizing_function.repeat_repetition().value();
                const auto& repeated_tracks = track_sizing_function.repeat_funcs();

                auto track_iter = impl::cycle(repeated_tracks);
                const auto take_count = repeated_tracks.size() * static_cast<size_t>(count);
                for(size_t i = 0; i < take_count; ++i)
                {
                    const auto& sizing_function = *track_iter.next();

                    tracks.push_back(GridTrack::New(
                        sizing_function.min_sizing_function(),
                        sizing_function.max_sizing_function()
                    ));
                    tracks.push_back(GridTrack::gutter(gap));
                    current_track_index += 1;
                }
            }
            else if(
                track_sizing_function.type() == TrackSizingFunction::Type::Repeat &&
                (
                    track_sizing_function.repeat_repetition().type() == GridTrackRepetition::Type::AutoFit ||
                    track_sizing_function.repeat_repetition().type() == GridTrackRepetition::Type::AutoFill
                )
            )
            {
                const auto repetition_kind = track_sizing_function.repeat_repetition().type();
                const auto& repeated_tracks = track_sizing_function.repeat_funcs();

                const auto auto_repeated_track_count = static_cast<size_t>(counts.Explicit - (static_cast<uint16_t>(track_template.size()) - 1));
                
                auto iter = impl::cycle(repeated_tracks);
                for(size_t i = 0; i < auto_repeated_track_count; ++i)
                {
                    const auto& track_def = *iter.next();

                    auto track =
                        GridTrack::New(track_def.min_sizing_function(), track_def.max_sizing_function());
                    auto gutter = GridTrack::gutter(gap);

                    // Auto-fit tracks that don't contain should be collapsed.
                    if( repetition_kind == GridTrackRepetition::Type::AutoFit && !track_has_items(current_track_index) ) {
                        track.collapse();
                        gutter.collapse();
                    }

                    tracks.push_back(track);
                    tracks.push_back(gutter);

                    current_track_index += 1;
               }
            }
        }
    }

    // Create positive implicit tracks
    if( auto_tracks.empty() ) {
        // let iter = core::iter::repeat(NonRepeatedTrackSizingFunction::AUTO);
        // create_implicit_tracks(tracks, counts.positive_implicit, iter, gap)
        create_implicit_tracks__repeat(tracks, counts.positive_implicit, NonRepeatedTrackSizingFunction::AUTO(), gap);
    } else {
        // let iter = auto_tracks.iter().copied().cycle();
        // create_implicit_tracks(tracks, counts.positive_implicit, iter, gap)
        create_implicit_tracks__cycle(tracks, counts.positive_implicit, auto_tracks, 0, gap);
    }

    // Mark first and last grid lines as collapsed
    // tracks.first_mut().unwrap().collapse();
    // tracks.last_mut().unwrap().collapse();
    tracks.front().collapse();
    tracks.back().collapse();
}

/// Utility function for repeating logic of creating implicit tracks
/* RUST
    fn create_implicit_tracks(
        tracks: &mut Vec<GridTrack>,
        count: u16,
        mut auto_tracks_iter: impl Iterator<Item = NonRepeatedTrackSizingFunction>,
        gap: LengthPercentage,
    ) {
        for _ in 0..count {
            let track_def = auto_tracks_iter.next().unwrap();
            tracks.push(GridTrack::new(track_def.min_sizing_function(), track_def.max_sizing_function()));
            tracks.push(GridTrack::gutter(gap));
        }
    }
*/
/* NOTE (why here is 2 functions instead 1)

    Original Rust 'create_implicit_track' function receive an iterator, and used
    in next cases:

        // 1)
        let iter = core::iter::repeat(NonRepeatedTrackSizingFunction::AUTO);
        create_implicit_tracks(tracks, counts.negative_implicit, iter, gap)

        // 2)
        let iter = auto_tracks.iter().copied().cycle().skip(offset);
        create_implicit_tracks(tracks, counts.negative_implicit, iter, gap)

        // 3)
        let iter = core::iter::repeat(NonRepeatedTrackSizingFunction::AUTO);
        create_implicit_tracks(tracks, counts.positive_implicit, iter, gap)

        // 4)
        let iter = auto_tracks.iter().copied().cycle();
        create_implicit_tracks(tracks, counts.positive_implicit, iter, gap)

    So, not to re-implement rust iterators, here we simple use specialized
    version:

        - create_implicit_tracks__repeat - for cases: 1) and 3)
        - create_implicit_tracks__cycle  - for cases: 2) and 4)
*/
inline void create_implicit_tracks__repeat(
    Vec<GridTrack>& tracks,
    uint16_t count,

    const NonRepeatedTrackSizingFunction& repeated,
    
    const LengthPercentage& gap
) 
{
    for(uint16_t _ = 0; _ < count; ++_) {
        tracks.push_back(GridTrack::New(repeated.min_sizing_function(), repeated.max_sizing_function()));
        tracks.push_back(GridTrack::gutter(gap));
    }
}
inline void create_implicit_tracks__cycle(
    Vec<GridTrack>& tracks,
    uint16_t count,
    
    Slice<NonRepeatedTrackSizingFunction const> cycled,
    size_t skip_offset,

    LengthPercentage gap
) {
    auto it = impl::cycle(cycled, skip_offset);

    for(uint16_t _ = 0; _ < count; ++_) {
        const NonRepeatedTrackSizingFunction& track_def = *it.next();

        tracks.push_back(GridTrack::New(track_def.min_sizing_function(), track_def.max_sizing_function()));
        tracks.push_back(GridTrack::gutter(gap));
    }
}

} // namespace taffy
